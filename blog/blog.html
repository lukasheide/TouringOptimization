<!-----

You have some errors, warnings, or alerts. If you are using reckless mode, turn it off to see inline alerts.
* ERRORs: 0
* WARNINGs: 1
* ALERTS: 31

Conversion time: 4.671 seconds.


Using this HTML file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β33
* Fri May 06 2022 06:02:26 GMT-0700 (PDT)
* Source doc: Tourenplanung Blogpost Draft
* Tables are currently converted to HTML tables.

WARNING:
Inline drawings not supported: look for ">>>>>  gd2md-html alert:  inline drawings..." in output.

* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server. NOTE: Images in exported zip file from Google Docs may not appear in  the same order as they do in your doc. Please check the images!

* Footnote support in HTML is alpha: please check your footnotes.
----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 1; ALERTS: 31.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>
<a href="#gdcalert6">alert6</a>
<a href="#gdcalert7">alert7</a>
<a href="#gdcalert8">alert8</a>
<a href="#gdcalert9">alert9</a>
<a href="#gdcalert10">alert10</a>
<a href="#gdcalert11">alert11</a>
<a href="#gdcalert12">alert12</a>
<a href="#gdcalert13">alert13</a>
<a href="#gdcalert14">alert14</a>
<a href="#gdcalert15">alert15</a>
<a href="#gdcalert16">alert16</a>
<a href="#gdcalert17">alert17</a>
<a href="#gdcalert18">alert18</a>
<a href="#gdcalert19">alert19</a>
<a href="#gdcalert20">alert20</a>
<a href="#gdcalert21">alert21</a>
<a href="#gdcalert22">alert22</a>
<a href="#gdcalert23">alert23</a>
<a href="#gdcalert24">alert24</a>
<a href="#gdcalert25">alert25</a>
<a href="#gdcalert26">alert26</a>
<a href="#gdcalert27">alert27</a>
<a href="#gdcalert28">alert28</a>
<a href="#gdcalert29">alert29</a>
<a href="#gdcalert30">alert30</a>
<a href="#gdcalert31">alert31</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>


<p>
(1/3) Einführung in die Welt der Tourenoptimierung 
</p>
<p>
In vielen Unternehmen fallen täglich verschiedenste Transportprozesse an. Klassische Beispiele sind die Optimierung von Warenein- und ausgängen, die Einsatzplanung von Servicetechnikern oder die optimale Auslieferreihenfolge bei Lieferdiensten. Ein Punkt, der mich besonders fasziniert, ist, dass Verfahren der Tourenoptimierung auch in völlig anderen Gebieten angewandt werden können. Ein typisches Beispiel ist das Bohren von Löchern in einer Leiterplatte mit einer automatischen Bohrmaschine, ein eher exotisches Beispiel ist die Übertragung auf das Anwendungsgebiet der Gensequenzierung<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>.
</p>
<p>
Zur Tourenoptimierung im Logistikbereich existieren eine ganze Reihe an fertigen Lösungen von verschiedenen Software-as-a-Service (SaaS)<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> Anbietern. Diese bringen verschiedene Vorteile mit sich: SaaS-Produkte können in der Regel schnell integriert und genutzt werden, sind meist flexibel skalierbar, erfordern weniger internes IT Know-how im Vergleich zu Individuallösungen und sind mit keinen oder geringen initialen Investitionskosten verbunden. Nachteile liegen in der hohen Abhängigkeit vom Anbieter und der Unsicherheit, ob die One-Size-fits-All-Lösung eines SaaS Anbieters alle Besonderheiten der eigenen Transportprozesse abbildet. Aus der Fahrradstadt Münster kommend, wird hier von einigen Logistikanbietern immer mehr auf das Fahrrad als Transportmittel für die letzte Meile gesetzt. Beim Einsatz von Tourenplanungs-SaaS-Produkten für die Planung von Fahrrädern als Transportmittel kommt es dabei doch häufiger zu Problemen, insbesondere bei den angegebenen Zeiten - gefahrene Geschwindigkeiten auf dem Rad sind stark abhängig von den individuellen FahrerInnen, aber auch von der gewählten Strecke mit ihren äußeren Gegebenheiten. Diese wichtigen Nebenbedingungen können in den meisten SaaS Lösungen nicht abgebildet werden. 
</p>
<p>
In einem Proof of Concept für einen unserer Kunden habe ich gezeigt, wie Tourenoptimierungs-Probleme beim Einsatz des Fahrrads für die letzte Meile mit individuellen Nebenbedingungen gelöst werden können. In einer dreiteiligen Blogreihe möchte ich einen kleinen Einblick in die Welt der Tourenoptimierung geben und auf praktische Umsetzungsmöglichkeiten eingehen. Im ersten Blogartikel diskutiere ich die theoretischen Grundlagen der Tourenoptimierung und gehe hier auf das bekannte Traveling Salesman Problem (TSP), gängige Nebenbedingungen und verschiedene Lösungsverfahren ein. Im zweiten Teil wird es praktisch: Hier stelle ich einen kleinen Showcase in einem Python Jupyter Notebook vor und zeige beispielhaft wie kleine Tourenoptimierungs-Probleme Schritt für Schritt gelöst und visualisiert werden können. Im dritten Teil werden die Ideen und Konzepte aus dem zweiten Teil weiter vertieft und um realistischere Nebenbedingungen und Anforderungen erweitert. Im letzten Teil der Reihe diskutiere ich dann noch einmal die Vor- und Nachteile von SaaS-Tourenoptimierungs-Providern und zeige warum der Trend wieder verstärkt zu Individuallösungen geht.
</p>
<p>
<br>Das Traveling Salesman Problem
</p>
<p>
Wie versprochen starten wir also erstmal mit etwas Theorie. Aber keine Sorge, es wird alles so gut wie möglich veranschaulicht. Wir gehen über die Grundlagen hinaus auf einige echt spannende Ansätze ein.
</p>
<p>
Ein viel bekanntes und gut erforschtes Problem, das so ziemlich allen Tourenoptimierungs-Problemen zu Grunde liegt, ist das so genannte Rundreisendenproblem (Englisch: Traveling Salesman Problem). Das Traveling Salesman Problem erfreut sich bei Uni-Dozenten hoher didaktischer Beliebtheit und wird - zumindest war es bei mir so - in vielen Vorlesungen angesprochen. Leider liegt häufig der Fokus ausschließlich auf den Grundlagen des TSP und warum verschiedene naive Verfahren eher weniger gut geeignet sind. Welche Lösungsansätze denn aber zielführender oder gar praxisrelevant sind, wird seltener vernünftig erklärt. Aber von vorne:
</p>
<p>
Die Grundidee des TSP ist einfach. Ein Handelsreisender möchte <em>n</em> verschiedene Kunden besuchen. Dazu startet er von einem Startpunkt, besucht in einer bestimmten Reihenfolge nacheinander alle <em>n</em> Kunden und kehrt dann wieder zu seinem Ausgangspunkt zurück. Gesucht ist nun die Tour, deren Gesamtstrecke am kürzesten ist. 
</p>
<p>


<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.gif). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image1.gif" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Klingt einfach? Ist es auch! Zumindest für eine kleine Anzahl von Kunden. Ist die Anzahl der Kunden gering oder sind diese günstig angeordnet, so lässt sich eine optimale Lösung visuell schnell finden.
</p>
<p>


<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image2.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Schwieriger wird es aber sehr schnell bei einer größeren Anzahl anzufahrender Zielpunkte, die zusätzlich ungünstig angeordnet sind. Unten dargestellt ist eine Tour, die 20 deutsche Städte verbindet. Ist die Tour optimal oder findet ihr vielleicht noch eine bessere Lösung? Und wie können wir überhaupt wissen, ob es noch eine bessere Lösung gibt? 
</p>
<p>


<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image3.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image3.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Exakte Lösungsverfahren und warum wir sie nicht nutzen
</p>
<p>
Eine sichere Art und Weise um die optimale Lösung zu finden oder zu überprüfen ob eine Lösung optimal ist, ist die <em>Brute-Force-Methode</em>. Im TSP-Kontext bedeutet dies alle Permutationen der Zielpunkte zu bilden und für jede Permutation die Routenlänge zu berechnen. Einfacher ausgedrückt, alle möglichen Touren bilden und dann vergleichen welche Tour am kürzesten ist. Dies ist auch für eine kleine Anzahl von Zielpunkten problemlos möglich. Zumindest für einen Computer. Allerdings wächst die Anzahl möglicher Touren extrem stark mit der Zahl an Zielpunkten, wie man auch in der unten abgebildeten Tabelle sehen kann. Und da “extrem stark” mathematisch etwas unpräzise ist, redet man hier von faktoriellem Wachstum. 
</p>

<table>
  <tr>
   <td>Anzahl Zielpunkte
   </td>
   <td>Anzahl möglicher Touren
   </td>
  </tr>
  <tr>
   <td>2
   </td>
   <td>2
   </td>
  </tr>
  <tr>
   <td>3
   </td>
   <td>6
   </td>
  </tr>
  <tr>
   <td>4
   </td>
   <td>24
   </td>
  </tr>
  <tr>
   <td>5
   </td>
   <td>120
   </td>
  </tr>
  <tr>
   <td>6
   </td>
   <td>720
   </td>
  </tr>
  <tr>
   <td>7
   </td>
   <td>5.040
   </td>
  </tr>
  <tr>
   <td>8
   </td>
   <td>40.320
   </td>
  </tr>
  <tr>
   <td>9
   </td>
   <td>362.880
   </td>
  </tr>
  <tr>
   <td>10
   </td>
   <td>3.628.800
   </td>
  </tr>
  <tr>
   <td>11
   </td>
   <td>39.916.800
   </td>
  </tr>
  <tr>
   <td>12
   </td>
   <td>479.001.600
   </td>
  </tr>
  <tr>
   <td>…
   </td>
   <td> 
   </td>
  </tr>
  <tr>
   <td>n
   </td>
   <td>n!
   </td>
  </tr>
</table>


<p>
Faktorielles Wachstum ist auf der unten abgebildeten Skala zum Vergleich des Wachstums von Ordungsklassen übrigens ganz rechts und damit, salopp gesagt, nicht gerade das was man gerne sehen würde. Es existieren zwar bessere exakte Lösungsverfahren, die aber immer noch exponentiell langsam sind. In der Komplexitätstheorie gehört das TSP zur Klasse der NP-schweren Probleme. Dies bedeutet aus praktischer Sicht<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>, dass sich das Problem nicht effizient optimal lösen lässt. Deswegen kommen in der Praxis in der Regel Heuristiken statt exakten Lösungsverfahren zum Einsatz. Heuristiken sind darauf ausgelegt schnell eine gute Lösung zu finden, die aber nicht zwingend die optimale sein muss. Übertragen auf das TSP bedeutet dies effizient eine kurze Tour, aber nicht zwingend die aller kürzeste, zu finden.
</p>
<p>


<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image4.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image4.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Aber wie berechnet man denn eigentlich genau die Länge einer Tour? Eine wichtige Voraussetzung zur Lösung des TSP ist, dass für jede Route zwischen zwei Punkten A und B die Distanz gegeben ist<sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup>. Dadurch lässt sich eine Distanzmatrix aufstellen, die ein wichtiger Grundbaustein für die Lösung des TSP ist. Mathematisch lässt sich das Problem dann als Graph darstellen. Jeder Punkt wird durch einen Knoten dargestellt und jede Route zwischen zwei Punkten als Kante zwischen den jeweiligen Knoten.
</p>
<p>


<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image5.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image5.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Da die Begriffe Touren- und Routenoptimierung immer mal wieder durcheinander geworfen werden (auch bei uns intern und sogar bei Menschen aus der Logistikbranche), hier noch einmal die Unterscheidung: Bei <em>Routenoptimierung</em> geht es darum die optimale Route von einem Punkt A zu einem Punkt B zu finden. <em>Tourenoptimierung</em> baut darauf auf, es wird also davon ausgegangen, dass dieses Problem bereits gelöst ist. Hier werden stattdessen verschiedene Zielpunkte zu einer Tour zusammengefasst, wobei der Fokus auf eine Festlegung der Reihenfolge der Zielpunkte liegt.
</p>
<p>


<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image6.gif). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image6.gif" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Heuristische Lösungsverfahren<br>
</p>
<p>
Greedy Approach
</p>
<p>
Zur Auffrischung fehlt noch ein weiterer Ansatz der auch sehr gerne in Vorlesungen erklärt wird: Der <em>Greedy-Approach</em>. Die Idee ist simpel: Wähle als nächsten Punkt immer den Zielpunkt, der dem vorherigem am nächsten liegt. Als <em>greedy</em> wird dieser Ansatz bezeichnet, da wir anfangs gierig nach möglichst kurzen Verbindungen suchen, was gegen Ende dazu führen kann, dass noch sehr ungünstige Strecken zurückgelegt werden müssen. Ihr erinnert euch an das Deutschland-Beispiel? Diese Lösung habe ich mit Hilfe des Greedy Ansatzes erstellt. Rechts seht ihr eine bessere Lösung, falls ihr sie oben nicht schon selbst gefunden habt. Die Gesamtdistanz ist mehr als 200 Kilometer kürzer. Es gibt eine ganze Reihe an solchen einfachen (und auch etwas komplizierteren) Verfahren.<sup id="fnref5"><a href="#fn5" rel="footnote">5</a></sup>
</p>
<p>


<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image7.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image7.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
k-opt Swap
</p>
<p>
So und jetzt kommen wir endlich zu den wirklich interessanten Lösungsansätzen. Der erste, den ich euch vorstellen möchte ist <em>k-opt-swap</em>. Dieser Ansatz ist eine so genannte Postoptimierungsheuristik. “Heuristik”, weil unser Ziel ist, eine sehr gute, aber nicht zwingend optimale Lösung zu finden und “Postoptimierung” weil <em>k-opt-swap </em>auf einer ersten initialen Lösung basiert und diese verbessern soll. So kann beispielsweise mit Hilfe des <em>greedy </em>Verfahrens eine Ausgangslösung erstellt werden, die dann mit <em>k-opt-swap </em>weiter verbessert wird. Die Idee des Ansatzes ist es k Verbindungen aus der bestehenden Lösungen herauszunehmen und durch k neue Verbindungen auszutauschen, wodurch wieder eine gültige Tour entstehen muss. Führt dieser Tausch zu einer Verbesserung, verringert sich also die Gesamtstrecke, so wird diese Änderung übernommen. Unten seht ihr ein Beispiel bei dem zwei Fahrten, durch zwei kürzere ersetzt werden. Dies ist also ein Beispiel für die 2-opt-swap Variante. Die bessere Lösung in der Grafik oben wurde mit Hilfe dieses Ansatzes erzeugt. Zunächst wurde mit Hilfe des Greedy Verfahrens eine Ausgangslösung erzeugt, die ich dann mit Hilfe von 2-opt-swap verbessert habe.
</p>
<p>


<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image8.gif). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image8.gif" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Ant Colony Optimization
</p>
<p>
Ein weiterer sehr spannender Ansatz ist die <em>Ant Annealing Colony Optimization </em>Methode<sup id="fnref6"><a href="#fn6" rel="footnote">6</a></sup>. Dieser Ansatz ist, wie der Name schon sagt, von Ameisenkolonien inspiriert und basiert auf der Pheromon-basierten Kommunikation von Ameisen. Diese hinterlassen Duftstoffe, Pheromone, um mit ihren Kolonie-Mitgliedern zu kommunizieren, z.B. bei der Suche nach neuen Nahrungsquellen. Diese Idee lässt sich mit Hilfe eines probabilistischen Algorithmus auf das Traveling Salesman Problem übertragen. Im Gegensatz zu den zuvor eingeführten deterministischen Verfahren, bei denen Wahrscheinlichkeiten und Zufall keine Rolle spielen, setzen probabilistische Verfahren auf eben diese. Der Algorithmus funktioniert in etwa folgendermaßen:
</p>
<ol>

<li>Eine virtuelle Ameise startet vom Ausgangspunkt und hat für ihre erste Strecke n Zielpunkte zur Auswahl. 

<li>Der nächste Punkt wird durch das Ziehen einer Zufallszahl ausgewählt. Da zu Beginn noch keine Pheromonspuren verteilt wurden, haben alle Punkte die gleiche Wahrscheinlichkeit gewählt zu werden<sup id="fnref7"><a href="#fn7" rel="footnote">7</a></sup>.  

<li>Es werden so lange Punkte ausgewählt, bis jeder Zielpunkt einmal besucht wurde.

<li>Anschließend wird für die gewählten Strecken eine Pheromonspur verteilt. Je kürzer die Gesamtstrecke, desto stärker fällt diese aus.

<li>Eine weitere Ameise startet. Stärkere Pheromonspuren führen dazu, dass es an einer Abzweigung wahrscheinlicher wird, dass eine Ameise dieser Spur folgt. 

<li>Am Ende jeder Runde verdunstet auch ein Anteil der Pheromonspuren. 
<p>
Auf diese Art und Weise legen die virtuellen Ameisen mit steigender Zahl an Durchläufen nach und nach immer optimalere Wege zurück, wodurch sich eine immer bessere Lösung für das Touring-Problem ergibt.
</p>
<p>


<p id="gdcalert9" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image9.gif). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image9.gif" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Im Gegensatz zu anderen Algorithmen hat dieser Ansatz den großen Vorteil, dass nachträgliche Änderungen, z.B. ein zusätzlicher Kunde der noch angefahren werden muss, eingebaut werden können, ohne dass wieder komplett von vorne gestartet werden muss. 
</p>
<p>
Fassen wir also noch einmal zusammen: Zur Lösung des Traveling Salesman Problem gibt es eine ganze Reihe an verschiedenen Verfahren. Da exakte Lösungsverfahren mindestens exponentielle Laufzeit haben und so schlecht mit wachsender Anzahl von Zielpunkten skalieren, werden in der Praxis in der Regel Heuristiken verwendet, mit denen sich gute, aber nicht zwingend die beste, Lösungen berechnen lassen. Im nächsten Blogartikel der Reihe (Link) zeige ich euch wie ihr in einem Python Jupyter Notebook kleinere gängige Tourenoptimierungs-Probleme lösen und visualisieren könnt. 
</p>
<p>
(2/3) Tourenoptimierung für Fahrradkuriere - Visualisierung und Lösungen Verfahren in einem Python Jupyter Notebook
</p>
<p>
In diesem Artikel möchte ich euch zeigen, wie ihr Tourenoptimierungs-Probleme in einem Python Jupyter Notebook lösen und visualisieren könnt. Am Beispiel eines Fahrradkurierdienst zeige ich außerdem wie das Grundproblem um gängige Nebenbedingungen erweitert werden kann. Dieser Artikel ist der zweite meiner Tourenoptimierungs-Blogreihe und baut auf dem ersten Blogbeitrag (Link) auf, in dem die theoretischen Grundlagen besprochen wurden. Mit ein paar Grundkenntnissen sollte ihr aber, auch ohne diesen Artikel gelesen zu haben, folgen können.
</p>
<p>
Anforderungsanalyse
</p>
<p>
Relevant für die Praxis ist in den allermeisten Fällen natürlich nicht die Basis Variante des Traveling Salesman Problem, sondern Abwandlungen von diesem. So gibt es eine ganze Reihe von Beschränkungen und Nebenbedingungen die zusätzlich berücksichtigt werden müssen. Bei vielen Transportproblemen stehen mehrere Fahrer oder Fahrzeuge zur Auswahl und es ist nicht von vornherein festgelegt, wer welchen Zielpunkt anfahren soll. Zusätzlich gibt es häufig Kapazitätsbeschränkungen. So kann ein Transporteur nur eine bestimmte Anzahl von Transportgütern transportieren. Typisch ist auch die Priorisierung bestimmter Kunden und die Einhaltung von Lieferzeitfenstern. Weiterhin muss sichergestellt werden, dass innerhalb kürzester Zeit auf wechselnde Bedingungen, z.B. neue kurzfristige Aufträge oder dynamische Verkehrsbedingungen, reagiert werden kann. Je nach Anwender kann auch die Berücksichtigung von wechselnde Wetterbedingungen oder unterschiedliche Ausliefergeschwindigkeiten von verschiedenen Fahrzeugen oder Fahrern wichtig sein. Diese Liste könnte noch beliebig erweitert werden. Die meisten der zuvor aufgezählten Punkte, sind zugleich super praxisrelevant und gut erforscht. Dadurch gibt es häufig schon fertige Lösungen für diese Nebenbedingungen. Zur reinen mathematischen Optimierung bieten sich z.B. verschiedene Open Source Lösungen an. Eine dieser Bibliotheken sind die <em>Google-OR-Tools (Link)</em>. Im nächsten Abschnitt zeige ich euch wie ihr mit Hilfe dieser Bibliothek einen einfachen Demo Case implementieren könnt und wie dieser in einem Jupyter Notebook mit Hilfe der <em>Folium</em> Bibliothek visualisiert werden kann. (Link zum Repo einfügen)
</p>
<p>
Bevor wir mit der Implementierung beginnen, sollten wir uns zunächst einmal Gedanken machen wie genau der Demo Case aussehen soll, den wir abbilden wollen. Dazu beginnen wir mit einem Grundproblem, lösen dieses und erweitern den Basisfall dann im nächsten Schritt um einige etwas realistischere Anforderungen. 
</p>
<p>
Basisfall: Ein Fahrer
</p>
<p>
Für unseren den Demo Case gehen wir von einem Fahrradkurier aus, der seine Kunden, ausgehend von einem Zentrallager, beliefern soll. Für den Basisfall nehmen wir an, dass die Zuteilung der Zielpunkte auf unsere verschiedenen Fahrer bereits erfolgt ist und auch Kapazitätseinschränkungen und Lieferzeitfenster nicht berücksichtigt werden müssen. Unser Fokus soll ausschließlich darauf liegen die 10 Zielpunkte in einer möglichst kurzen Route effizient miteinander zu verbinden und das Ergebnis zu visualisieren. Dafür habe ich 10 zufällige Adressen in Münster gewählt. Das grüne Icon symbolisiert dabei den Start- und Endpunkt. Die 10 blauen Icons symbolisieren die Zielpunkte.
</p>
<p>


<p id="gdcalert10" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image10.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image10.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Also an die Umsetzung. Zunächst einmal müssen ein paar Bibliotheken importiert und vielleicht auch noch installiert werden. Neben den vermutlich bekannten Bibliotheken <em>Pandas</em> und <em>Numpy </em>zum Data Handling, benötigen wir <em>Folium </em>zur Erstellung von Karten, ähnlich der oben abgebildeten, <em>geopy </em>zum Bestimmen der Geokoordinaten unserer Zieladressen, <em>ortools </em>zur Tourenoptimierung und <em>pyroutelib3 </em>zur Routenoptimierung.<sup id="fnref8"><a href="#fn8" rel="footnote">8</a></sup> 
</p>
<p>


<p id="gdcalert11" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image11.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image11.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Als nächstes erstellen wir dann eine Liste von zufällig ausgewählten Adressen in Münster. 
</p>
<p>


<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image12.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image12.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Um die Geo-Koordinaten der Adressen abzurufen nutzen wir die geopy-Library. Nominatim ist ein Geocoding-Tool, welches basierend auf OpenStreetMaps Daten die Geo-Koordinaten von Adressen ermitteln kann. Dazu iterieren wir einfach über jede Adresse in der Liste und erstellen eine neue Liste, die zu jedem Zielpunkt die Adresse und die Geo-Koordinaten beinhaltet.
</p>
<p>


<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image13.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image13.png" width="" alt="alt_text" title="image_tooltip">
 
</p>
<p>
Außerdem erstellen wir noch ein Ausgangslager, welches am Münsteraner Hafen liegen soll.  
</p>
<p>
<br>

<p id="gdcalert14" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image14.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert15">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image14.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Im nächsten Schritt können wir nun bereits die zu Beginn gezeigte Karte visualisieren. Dazu verwenden wir die Bibliothek Folium, welche als Python Wrapper um die beliebte Leaflet Javascript Library zur Erstellung von interaktiven Karten verwendet wird.<br>Im ersten Schritt erstellen wir zunächst eine Karte zentriert auf die Koordinaten des Zentrallagers. Das Zoom-Level stellen wir so hoch, dass wir einen schönen Überblick über Münster bekommen. Als nächstes erstellen wir ein Icon für das Zentrallager. Neben den Koordinaten, dem Inhalt beim Hovern (Tooltip) und dem Inhalt des Popup-Fensters, lässt sich auch die Farbe und das Icon anpassen. Neben einigen built-in Icons können auch Font-Awesome v4 Icons<sup id="fnref9"><a href="#fn9" rel="footnote">9</a></sup> verwendet werden. Ein solches wird hier beispielhaft für das Zentrallager verwendet. Abschließend iterieren wir über die Zielpunkte, erstellen auch hier jeweils ein Icon und geben dann die resultierende Karte aus. 
</p>
<p>


<p id="gdcalert15" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image15.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert16">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image15.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>


<p id="gdcalert16" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image16.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert17">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image16.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Im nächsten Schritt soll nun die Distanzmatrix zwischen unseren Zielpunkten und unserem Ausgangspunkt aufgestellt werden. Dazu benötigen wir zwei Hilfsfunktionen. Die erste dient dem Zweck die Distanz zwischen zwei Punkten zu berechnen. Der Einfachheit halber verzichten wir für den Moment darauf die genaue Fahrdistanz zu verwenden, sondern nutzen die Luftlinie zwischen zwei Punkten als Proxy für die tatsächliche Entfernung. Zum Erstellen der Distanzmatrix verwenden wir eine Funktion, die als flexibles Rückgabeformat entweder ein Pandas DataFrame oder ein Numpy Array zurückgeben kann. Während auf das Numpy Array mit Hilfe der Zielpunkt-Indizes einfach zugegriffen werden kann, kann mit dem Pandas DataFrame eine übersichtliche Tabelle erstellt werden, um vor allem beim Entwickeln schnell überprüfen zu können, ob alles wie erwartet funktioniert. 
</p>
<p>


<p id="gdcalert17" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image17.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert18">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image17.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Nun müssen wir lediglich die Liste aus Zieladressen und Ausgangspunkt verbinden und die zuvor erstellen Funktionen nutzen um die Matrix zu erstellen.
</p>
<p>


<p id="gdcalert18" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image18.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert19">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image18.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Optimierung mit Google OR-Tools
</p>
<p>
Und jetzt kommt der interessante Part: Das Finden einer effizienten Tour. Natürlich könnten wir dafür eine der Funktionen verwenden, die im ersten Blogartikel (Link) eingeführt wurden. Ich habe euch aber versprochen einen kleinen Einblick in die Google OR-Tools Library für Tourenoptimierung zu geben. Da ihr mit dieser mächtigen Bibliothek außerdem auch die gängigsten Beschränkungen und Nebenbedingungen ohne großen Implementierungsaufwand abbilden könnt, kommt jetzt die Einführung.
</p>
<p>
Zunächst müssen wir einen Index Manager und ein Routing Model Objekt erstellen. Der Index Manager wird genutzt, um die internen Indizes des Solvers, in die, von uns in der Distanzmatrix verwendeten, Indizes zu konvertieren. Dazu übergeben wir die Anzahl der Knoten, also alle 11 Punkte, die Anzahl der Fahrzeuge und den Index unseres Ausgangspunktes. Das Routing Model Objekt ist das zentrale Objekt um das sich ab jetzt so ziemlich alles dreht. Sobald alles konfiguriert ist, kann mit Hilfe der Solve-Methode eine Lösung berechnet werden. 
</p>
<p>


<p id="gdcalert19" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image19.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert20">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image19.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Vorher müssen wir aber noch ein paar weitere Konfigurationen treffen. Als nächstes wird eine Callback-Funktion benötigt, welche die Distanz zwischen zwei Punkten zurückgibt. Hier werden also die Distanzmatrix und das Routing Model miteinander verknüpft. <br>Weiterhin müssen noch die Kosten für das Wählen einer Verknüpfung zwischen zwei Punkten festgelegt werden. Moment mal, haben wir das nicht gerade gemacht? Nicht ganz. In unserem Fall wollen wir einfach als Kosten die Distanz zwischen zwei Punkten verwenden. Theoretisch könnte man aber hier auch noch weitere oder alternative Faktoren einfließen lassen. Beispielsweise könnte hier statt der Distanz die Fahrzeit und somit auch mögliche Geschwindigkeitsunterschiede bei verschiedenen Fahrern oder Fahrzeugen berücksichtigt werden.<br>Als nächstes müssen wir uns noch für eine Methode entscheiden nach der optimiert werden soll. Wir wählen dafür einfach die Default Strategie. Außerdem setzen wir die First Solution Strategie auf den Greedy Ansatz, ähnlich wie im ersten Teil dieser Reihe beschrieben (Link). <br>Abschließend können wir mit der Methode <em>SolveWithParameters</em> die Lösung berechnen lassen.
</p>
<p>


<p id="gdcalert20" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image20.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert21">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image20.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Zur Ausgabe des berechneten Tourenplans benötigen wir nun eine weitere Hilfsfunktion. Hier iterieren wir über die zuvor berechnete Lösung<em> </em>und erstellen eine Liste, welche die geplante Reihenfolge enthält. Da wir später die Funktion auch für Touren mit mehreren Fahrzeugen nutzen wollen, berücksichtigen wir dies gleich mit und erstellen für jedes Fahrzeug eine weitere eigene Liste, die die geplante Tour enthält.
</p>
<p>


<p id="gdcalert21" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image21.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert22">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image21.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Perfekt, jetzt fehlt eigentlich nur noch die Visualisierung. Dazu erweitern wir unseren bestehenden Code um eine Schleife, die die einzelnen Zielpunkte unserer Tour miteinander verbindet. Auch hier abstrahieren wir zunächst von den tatsächlichen Routen zwischen zwei Zielpunkten und zeichnen stattdessen eine gerade Linie zwischen zwei Punkten.<br>
</p>
<p>


<p id="gdcalert22" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image22.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert23">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image22.png" width="" alt="alt_text" title="image_tooltip">
 
</p>
<p>
Das sieht doch schon ganz schick aus, oder?
</p>
<p>


<p id="gdcalert23" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image23.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert24">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image23.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Im nächsten Artikel der Reihe erweitern wir den Demo Case um exakte Routen zwischen zwei Zielpunkten, statt weiter die Luftlinien als Proxy für die tatsächliche Entfernung zu nutzen. Außerdem zeige ich, wie das Grundproblem um realistischere Anforderungen wie mehrere Fahrzeuge und Kapazitätsbeschränkungen erweitert werden kann.
</p>
<p>
(3/3) Praxis: Tourenoptimierung für Fahrradkuriere - Echte Routen und realistischere Nebenbedingungen
</p>
<p>
In diesem Artikel möchte ich euch mit Hilfe eines Python Jupyter Notebooks (Link) zeigen wie ihr Tourenoptimierungs-Anwendungsfälle inklusive Nebenbedingungen lösen und visualisieren könnt. Außerdem zeige ich euch wie ihr mit Hilfe von OpenStreetMaps die Route zwischen zwei Punkten für verschiedene Transportmodi berechnen lassen könnt. Dieser Artikel gehört zu meiner dreiteiligen Tourenoptimierungs-Blogreihe und baut auf dem zweiten Blogbeitrag (Link) auf, in dem ich gezeigt habe, wie ein einfaches Traveling Salesman Problem (TSP) praktisch gelöst und visualisiert werden kann. Schaut euch diesen Artikel am besten vorher an, da wir stark auf dem vorherigen aufbauen werden.
</p>
<p>
Von der Luftlinie zu echten Routen
</p>
<p>
Ihr wollt also gerne sehen wie man die Routen zwischen zwei Zielpunkten berechnet, damit die bisherige Planung nicht nur für fliegende Fahrräder funktioniert? 
</p>
<p>


<p id="gdcalert24" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image24.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert25">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image24.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Auch hierfür setzen wir auf OpenStreetMaps. Die <em>pyroutelib3</em><sup id="fnref10"><a href="#fn10" rel="footnote">10</a></sup><em> </em>Library bietet eine ganze Reihe von verschiedenen Transportmodi: Auto, Fahrrad, Bahn und sogar Pferd. Wir nehmen natürlich passend zum Anwendungsfall und, um dem Ruf der Stadt Münster gerecht zu werden, das Rad. Als nächstes müssen wir uns entscheiden auf welche Art die Routen gespeichert werden sollen. Ich habe mich hier für eine verschachtelte Liste entschieden:
</p>
<p>
Auf der ersten Ebene sollen die einzelnen Touren, bzw. Fahrzeuge liegen (aktuell haben wir weiterhin nur ein einzelnes Fahrzeug). Auf der zweiten Ebene dann immer eine Route von einem Zielpunkt zum nächsten (z.B. vom Ausgangslager zum ersten Kunden) und dann auf der dritten Ebene eine Liste aus Tupeln mit den einzelnen Geo-Koordinaten für jeden Pfad. Also von einem Knoten zum nächsten auf unserer Route.
</p>
<p>
  

<p id="gdcalert25" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image25.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert26">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image25.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Um das noch besser zu verdeutlichen visualisieren wir am besten direkt einmal das Ergebnis. Dazu müssen wir über die verschachtelte Liste iterieren und für jede Verbindung von einem Knoten zum Folgeknoten eine gerade Linie zeichnen. Das erreichen wir durch eine kleine Anpassung beim Erstellen der Karte.
</p>
<p>


<p id="gdcalert26" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image26.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert27">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image26.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Das Ergebnis sieht dann wie folgt aus: 

<p id="gdcalert27" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image27.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert28">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image27.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Wer sich in Münster gut auskennt, erkennt schnell, dass ein Teil der Route auf der Münsteraner Promenade liegt, auf der lediglich Radfahrer zugelassen sind. Das Ergebnis kann sich also sehen lassen.
</p>
<p>
<br>Erweiterung - Mehrere Fahrer und begrenzte Kapazitäten
</p>
<p>
Als nächstes möchte ich euch noch zeigen wie durch ein paar kleine Anpassungen der Ansatz um gängige Nebenbedingungen wie mehrere Fahrzeuge oder Kapazitätsbeschränkungen erweitern werden kann. Kapazitätsbeschränkungen können dabei z.B. ein maximales Volumen oder Gewicht pro Fahrzeug darstellen. Im Folgenden erweitern wir den Demo Case um die Annahme, dass es drei Fahrer gibt, wobei eines der Fahrräder ein Lastenrad mit größerem Volumen ist. Außerdem ergänzen wir das Volumen der Produkte, die unsere verschiedenen Kunden erwarten. Darüber hinaus müssen wir beim <em>IndexManager</em> berücksichtigen, dass mehrere Transportmittel zur Verfügung stehen. Der darauf folgende Teil bleibt gleich und muss nicht geändert werden. Zusätzlich müssen wir jetzt aber noch ein Demand Callback hinzufügen um die Kapazitätsbeschränkungen mit einzubauen. Dieses Callback ähnelt dem <em>Distance Callback </em>und gibt zu jedem Zielpunkt das zugehörige Nachfragevolumen zurück. Anschließend muss der <em>Demand Callback </em>lediglich noch mit unserem <em>Routing Model </em>verknüpft werden. Auch dies funktioniert, ähnlich wie beim <em>Demand Callback,</em> mittels der <em>RegisterUnaryTransitCallback </em>Methode. Auch hier gibt es eine ganze Reihe an Einstellungsmöglichkeiten. So können beispielsweise mittels einer Slackvariable Warte-, bzw. Servicezeiten berücksichtigt werden, was bei anderen Dimensionen sinnvoll sein kann, wir hier aber nicht wollen.
</p>
<p>


<p id="gdcalert28" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image28.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert29">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image28.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Abschließend müssen wir lediglich noch die Lösung berechnen lassen. Und die dann noch visualisieren. Um die Marker für die verschiedenen Touren farblich zu unterscheiden, lassen wir uns eine Liste der verfügbaren Farben ausgeben. Diese Liste kann dann bei der Erstellung der Marker genutzt werden, um die Touren gut auseinander halten zu können. <br>Da ich statt der tatsächlichen Routen gerade Linien etwas übersichtlicher finde, nutze ich diese auch wieder anstelle der tatsächlichen Routen. 
</p>
<p>


<p id="gdcalert29" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image29.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert30">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image29.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>


<p id="gdcalert30" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image30.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert31">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image30.png" width="" alt="alt_text" title="image_tooltip">

</p>
<p>
Auf diese Art und Weise kann man also mit vergleichsweise geringem Aufwand bereits etwas realistischere Tourenptimierungsprobleme lösen. 
</p>
<p>
Fazit
</p>
<p>
In der Praxis gibt es natürlich noch weit mehr Nebenbedingungen, die beachtet werden müssen, wie z.B. Lieferzeitfenster, Priorisierung von Zielpunkten, verschiedene Fahrzeugtypen, die unterschiedlich gut für bestimmte Produkte geeignet sind, und so weiter. Erfahrenen Anwendern fallen hier wahrscheinlich sofort eine ganze Liste an weiteren Anforderungen ein, die eine Tourenplanung Lösung für ihren Anwendungsfall abdecken sollte. Zum Abschluss möchte ich noch einmal auf den zu Beginn der Blogreihe beschriebenen Praxisfall zurückkommen:
</p>
<p>
Unser Kunde, der bisher auf eine SaaS-Tourenoptimierungs-Lösung gesetzt hatte, kam auf uns zu, da es eine Reihe an Problemen mit der bestehenden Lösung gab und er sich nach einer Erweiterung oder Alternative zur bisherigen Lösung erhofft hatten. Eine erste Analyse ergab, dass die bisherige Lösung große Probleme mit dem Transportmodus Rad hatte. Insbesondere bei der Zeitplanung, also einzuschätzen zu welchem Zeitpunkt sich welcher Fahrer wo befindet, gab es große Probleme. Dies war unter anderem auf die unterschiedlichen Fahrgeschwindigkeiten bei den Fahrern zurückzuführen. Selbstverständlich gibt es diese je nach Verkehrsaufkommen auch im Autoverkehr. Gerade bei längeren Fahrwegen gibt es aber bei Fahrradkurieren, im Gegensatz zu befahrenen Lieferdiensten, eine deutlich größere Varianz bei den Ausliefergeschwindigkeit, welche u. a. auf den Fahrrad-Typ aber auch auf die Erfahrung und Sportlichkeit des Fahrers zurückzuführen ist. Im Unternehmen ist zwar durchaus bekannt welche Fahrer schneller als andere sind. Schätzungen der Tourendauer basierten allerdings rein auf dem Bauchgefühl des Operationsteams und nicht auf datenbasierten Berechnungen. Dieses Problem ist ein gutes Beispiel warum insgesamt der Trend wieder vermehrt zu Individuallösungen geht. Individuallösungen muss dabei übrigens nicht heißen, dass eine Anwendung von Null auf neu gebaut wird. Ein Baukastenprinzip ermöglicht es hier verschiedene Grundmodule, die sehr gängige Komponenten beinhalten, miteinander zu verbinden um sich dann auf die spezielleren Anforderungen zu konzentrieren. <br>Wenn ihr eigene Erfahrungen oder Fragen und Anmerkungen habt, dann freue ich mich auf eine Diskussion in den Kommentaren.
</p>
<p>
Alternative 2: (nur falls es den vierten Artikel doch noch geben soll)
</p>
<p>
In der Praxis müssen natürlich noch weit mehr Restriktionen, Nebenbedingungen und Sonderfälle berücksichtigt werden. Was es da noch so zu beachten gilt und warum der Trend wieder vermehrt zu Individualsoftwarelösungen im Bereich Touringoptimierung geht, verrate ich euch im letzten Blogpost (Link) der Reihe.
</p>
<p>
(4/4) Praxis: SaaS-Touring-Produkte vs. Individuallösungen
</p>
<p>
Zur Planung und Optimierung von Touren gibt es eine ganze Reihe an SaaS-Providern. Viele Anbieter werben damit, dass ihre Lösungen flexibel auf unterschiedlichste Arten von Logistik-Use-Casen anwendbar sind und eine breite Auswahl an Sonderfällen abdecken. Dieser Blogbeitrag gehört zu einer dreiteiligen Reihe in der ich versuche einen Einblick in das facettenreiche Feld der Tourenoptimierung zu geben (Link zu erstem Artikel). In diesem Artikel vergleiche ich SaaS- und Individuallösungen zur Tourenoptimierung und gehe auf die Vor- und Nachteile beider Ansätze ein. Außerdem möchte ich von den Erfahrungen eines unserer Kunden - ein Logistik-Start-Up für die letzte Meile, welches auf Fahrradkuriere und somit nachhaltige Lieferungen setzt - mit einem SaaS-Anbieter berichten.
</p>
<p>
SaaS-Anbieter
</p>
<p>
Fd
</p>
<p>
In den ersten Gesprächen mit unserem Kunden zeichnete sich schnell ab, dass es eine ganze Reihe von Problemen mit ihrem Saas-Tourenoptimierungs-Anbieter gibt, die mit unserer Hilfe beheben werden sollten. Wie genau und was genau das eigentliche Problem war, haben wir mit Hilfe einer klassischen Anforderungsanalyse in mehreren Gesprächen zunächst einmal gemeinsam herausgearbeitet.
</p>
<p>
Es lässt sich also festhalten, dass die meisten SaaS-Anbieter grundsätzlich eine gute Anzahl der gängigsten Praxisanforderungen und Restriktionen berücksichtigen können. Für die Entscheidung zwischen einer Individuallösung und einer fertigen Produktlösung ist es wichtig insbesondere zwei Fragen zu beantworten: 
</p>
<ul>

<li>Wie ähnlich ist mein Anforderungsprofil zu denen von anderen Unternehmen? 

<li>Wie wichtig ist mir Flexibilität hinsichtlich Erweiterungen?
</li>
</ul>
</li>
</ol>
<p>
Grundsätzlich sollte man immer im Hinterkopf behalten, dass Produktlösungen nur typische Anforderungen erfüllen können, die in vielen Anforderungsprofilen enthalten sind. Gibt es irgendwelche Besonderheiten oder Spezialfälle in einem Geschäftsmodell die eher untypisch sind, so ist davon auszugehen, dass diese nicht einmal eben mit einer Produktlösung abgebildet werden können. Ein Beispiel für einen solchen Sonderfall stellt das Transportmittel Rad bei unserem Kunden dar. Zum einen optimierte das betreffende SaaS-Touringprodukt die Fahrtstrecken für den Autoverkehr und nicht für Fahrräder was in einigen Fällen zu suboptimalen Touren führte. Dieses Problem ist aber vermutlich eher Anbieterspezifisch und kann meines Wissens nach bei anderen Anbietern besser gelöst werden. Das viel speziellere Problem bei Fahrrädern als Transportmittel sind die unterschiedlichen Geschwindigkeiten der verschiedenen Fahrer. Selbstverständlich gibt es diese auch im Autoverkehr, insbesondere verursacht durch hohes Verkehrsaufkommen. Gerade bei längeren Fahrwegen gibt es aber bei Fahrradkurieren, im Gegensatz zu befahrenen Lieferdiensten, deutlich größere Unterschiede die sich stark auf die Ausliefergeschwindigkeit auswirken. Ein riesen Problem unseres Kunden war es, dass es bei der Tourenplanung keine zuverlässigen Prognosen für die Liefer- und Rückkehrzeiten der einzelnen Fahrer gab. Es war zwar durchaus bekannt welche Fahrer schneller als andere sind. Diese Annahmen basierten aber eher auf dem Bauchgefühl des Operationsteams, als datenbasierten Berechnungen. Und hier kommt auch direkt das nächste große Problem: Unser Kunde kann lediglich für eine begrenzte Zeitdauer von nicht einmal zwei Wochen auf die eigenen Tourenplanungen zugreifen. Für eine Bereitstellungen der eigenen Planungsdaten wäre eine nicht unerhebliche Summe anfällig geworden. Auch dies ist ein wichtiger Punkt, der natürlich nicht bei allen Anbietern problematisch ist. Trotzdem sollte dies bei der Entscheidung unbedingt berücksichtigt werden. Ein weiterer wichtiger Punkt ist die Frage wie dynamisch Änderungen in der Tourenplanung berücksichtigt werden können. Kurzfristige Auftragsänderungen, Verspätungen, wechselnde Verkehrsbedingungen oder … können schnell dazu führen dass ein Tourenplan durcheinander geworfen wird. Viele Produktlösungen sind eher statischer Natur und können nicht in Echtzeit auf Änderungen eingehen. Dies ist aber zum Beispiel dann wichtig, wenn es mehrere Abhol- und Lieferstellen gibt, statt einem einzigen Zentrallager. Wird eine Tour nicht immer von einem einzelnen zentralen Punkt gestartet, dann ist es umso wichtiger, dass innerhalb kürzester Zeit auf neue Aufträge oder sonstige Änderungen dynamisch reagiert werden kann.
</p>
<p>


<p id="gdcalert31" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline drawings not supported directly from Docs. You may want to copy the inline drawing to a standalone drawing and export by reference. See <a href="https://github.com/evbacher/gd2md-html/wiki/Google-Drawings-by-reference">Google Drawings by reference</a> for details. The img URL below is a placeholder. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert32">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="https://docs.google.com/drawings/d/12345/export/png" width="80%" alt="drawing">

</p>
<p>
Stichpunkte:
</p>
<ul>

<li>Erklärung Case, der gelöst werden soll (evtl. sagen, dass dies echte Daten für einen Probelauf an einem neuen Standort waren)

<li>Jupyter Notebook durchgehen 
<ul>
 
<li>Dabei zum einen zeigen, wie man mit Open Streetmaps Geo Daten einlesen kann  
<ul>
  
<li>Kurze Diskussion: Open Street Maps vs Google Maps API
</li>  
</ul>
 
<li>Wie Distanzmatrix erzeugt wird (nur wenn “fancy”)
 
<li>Wie Problem mit Google OR Tools gelöst werden kann
 
<li>Wie mit Folium visualisiert werden kann
</li> 
</ul>

<li>Message: Selbst in diesem Basic Use Case outperformed unser Ansatz die SaaS-Lösung

<li>Nächster Abschnitt:  
<ul>
 
<li>Weitere Erklärungen Problem SaaS Lösung:  
<ul>
  
<li>s. Board
</li>  
</ul>
 
<li>Kurzer Teaser wie wir diese Probleme lösen, bzw. sie angehen:  
<ul>
  
<li>“genauere Details können wir hier natürlich nicht verraten”
</li>  
</ul>
</li>  
</ul>

<li>Abschlussmessage: 
<ul>
 
<li>Tours planning SaaS solutions are limited to base cases and inflexible when it comes to addressing constraints beyond the general case.
 
<li>Verallgemeinerung mit reinnehmen: Auf welche anderen Use Cases lässt sich unsere Anwendung anwenden? z.B. Teaser auf andere Logistikprobleme (Roboter aufgreifen)

<!-- Footnotes themselves at the bottom. -->

<h2>Notes</h2>
<div class="footnotes">
<hr>
<ol><li id="fn1">
<p>
     Wenn euch das Thema interessiert schaut doch später mal hier rein: <a href="https://www.i-programmer.info/news/181-algorithms/9340-traveling-salesman-applied-to-dna-synthesis.html">https://www.i-programmer.info/news/181-algorithms/9340-traveling-salesman-applied-to-dna-synthesis.html</a> &nbsp;<a href="#fnref1" rev="footnote">&#8617;</a><li id="fn2">
<p>
     <a href="https://de.wikipedia.org/wiki/Software_as_a_Service">https://de.wikipedia.org/wiki/Software_as_a_Service</a> &nbsp;<a href="#fnref2" rev="footnote">&#8617;</a><li id="fn3">
<p>
     Aus theoretischer Sicht nur vermutlich, da bisher lediglich für kein NP-vollständiges Problem bewiesen werden könnte, dass es in polynomieller Zeit lösbar wäre.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a><li id="fn4">
<p>
     Je nachdem worauf man optimieren möchte muss dies nicht die Wegstrecke sein, sondern kann z.B. auch die durchschnittliche Fahrtdauer sein.&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a><li id="fn5">
<p>
     Hier findet ihr eine Auflistung einiger Verfahren: <a href="https://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden#Er%C3%B6ffnungsverfahren">https://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden#Er%C3%B6ffnungsverfahren</a>. &nbsp;<a href="#fnref5" rev="footnote">&#8617;</a><li id="fn6">
<p>
     Wer etwas mehr Zeit hat, dem kann ich diesen super Science Slam zum gleichen Thema von Adrian Lison empfehlen: <a href="https://www.youtube.com/watch?v=xJZNRZIQZSw">https://www.youtube.com/watch?v=xJZNRZIQZSw</a> &nbsp;<a href="#fnref6" rev="footnote">&#8617;</a><li id="fn7">

<p>
     Alternativ werden häufig die Anfangswahrscheinlichkeiten basierend auf den Entfernungen der Zielpunkte gesetzt werden, was in der Regel dazu führt, dass das Ergebnis schneller zum Optimum konvergiert und so weniger Iterationen benötigt werden.&nbsp;<a href="#fnref7" rev="footnote">&#8617;</a><li id="fn8">
<p>
     Wenn ihr euch nicht sicher seid, was der Unterschied ist, dann schaut doch noch einmal in den ersten Blogartikel (Link).&nbsp;<a href="#fnref8" rev="footnote">&#8617;</a><li id="fn9">
<p>
     Aktuell nur fontawesome Version 4! <a href="https://fontawesome.com/v4/">https://fontawesome.com/v4/</a> &nbsp;<a href="#fnref9" rev="footnote">&#8617;</a><li id="fn10">
<p>
     <a href="https://openbase.com/python/pyroutelib3/documentation">https://openbase.com/python/pyroutelib3/documentation</a>&nbsp;<a href="#fnref10" rev="footnote">&#8617;</a>

</ol></div>